---
layout: post
title: iOS14.8&#58; Patch CVE-2021-1740 again silently

---

As well known, iOS14.8 patched two 0 days in the wild, one of which is the __pegasus__ 0-click vulnerability. You can get the root cause and more interesting findings by reading my analysis from [here](https://www.trendmicro.com/en_us/research/21/i/analyzing-pegasus-spywares-zero-click-iphone-exploit-forcedentry.html). 

By the way, it also patched `CVE-2021-1740` again silently, no CVE assigned.

When I study the DefCon topic [Caught you - reveal and exploit IPC logic bugs inside Apple](https://media.defcon.org/DEF%20CON%2029/DEF%20CON%2029%20presentations/Zhipeng%20Huo%20Yuebin%20Sun%20Chuanda%20Ding%20-%20Caught%20you%20-%20reveal%20and%20exploit%20IPC%20logic%20bugs%20inside%20Apple.pdf) , I found the patch of `CVE-2021-1740` is still vulnerable.

The DefCon slides has already given the details of the root causes, and also shared 2 exploitations.

__The first exploitation (Arbitrary File Read)__ :

![image-20210915145918426](../res/2021-9-15-CVE-2021-1740-Invalid-Patch/image-20210915145918426.png)

__The second exploitation (Arbitrary File Write)__ : 

![image-20210915145944800](../res/2021-9-15-CVE-2021-1740-Invalid-Patch/image-20210915145944800.png)

__The old patch (Still vulnerable)__ :

![image-20210915144258578](../res/2021-9-15-CVE-2021-1740-Invalid-Patch/image-20210915144258578.png)

- Yes, it can stop the second exploitation. We have no time window to replace the target temporary file with  a symbolic link, because we canâ€™t know the temporary file name before the API `clonefileat`.
- Unfortunately, it cannot stop the first exploitation. If the `plist_file` is replaced with a symbolic link before the API `clonefileat`, then the temporary file with a random name could still be cloned. Therefore, the arbitrary file read issue still exists because the temporary file is accessible by common users.

__Proof Of Concept__

It is a `TOCTOU` issue, so I made a quick POC through my debugger :

- Attach my debugger to the `cfprefsd` process, set a breakpoint before the API call `clonefileat` in the function `-[CFPDSource cloneAndOpenPropertyListWithoutDrainingPendingChangesOrValidatingPlist]`

  ![image-20210915151138304](../res/2021-9-15-CVE-2021-1740-Invalid-Patch/image-20210915151138304.png)

- Create a normal plist file (whose __size larger than 0x100000 = 1M__) at `/tmp` directory.

- Fire a XPC request to the `cfprefsd`, for reading the preference value in the plist file.

- Then it hit my breakpoint, it is time to replace the plist file with a symbolic link now (point to a privacy file).

- Step over the API `clonefileat`, we can see the privacy file was cloned to a file with a random name as expected. The temporary file is readable by common users even it is a random name !

- Before the `unlink` of the temporary file, we still have a __time window to backup it__.

- How can we know the random file name ? There could be many methods to get it. The simplest way could be enumerating the files inside the directory :

  ```objective-c
  chdir("/tmp/test");
  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
          DIR *dp;
          struct dirent *ep;
          int cnt=0;
          while (1) {
              dp = opendir ("./");
              while ((ep = readdir (dp))) {
                  if (strlen(ep->d_name) == 21) { //strlen(abc.plist.cfp.XXXXXXX)==21
                      copyfile(ep->d_name, "secret_backup", 0, COPYFILE_ALL);
                      printf("Got it:%s.\n", ep->d_name);
                      goto END;
                  }
              }
              closedir (dp);
              cnt++;
          }
      END:
          printf("done with %d loops.\n", cnt);
  });
  ```

__New fix in iOS14.8, No CVE__

![image-20210915152721001](../res/2021-9-15-CVE-2021-1740-Invalid-Patch/image-20210915152721001.png)

We can see it uses API `fclonefileat` now, and the `src_fd` is returned by API `openat`, with `flag=0x100` (__O_NOFOLLOW__) to stop following the symlinks attack.

